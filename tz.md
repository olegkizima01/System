Передмова:
Це комплексне Технічне Завдання (ТЗ) на реалізацію Універсальної Мульти-Агентної Системи. Документ визначає архітектуру взаємодії агентів, рольову модель та інтеграцію з підсистемою розробки.

⸻

ТЕХНІЧНЕ ЗАВДАННЯ
Мульти-Агентна Система "Trinity" з Інтегрованим Контуром Розробки

⸻

1. Концепція Системи

Створення автономної інтелектуальної системи, де *група спеціалізованих агентів* спілкується між собою у вільному форматі (як команда інженерів), спільно вирішуючи складні завдання.

**Ключові принципи:**
1.  **Conversation-First:** Агенти ведуть діалог, сперечаються, перевіряють один одного та планують дії перед виконанням.
2.  **Role Separation:** Чіткий розподіл ролей (Архітектор, Виконавець, Ревізор/Безпека).
3.  **Dev Subsystem Encapsulation:** Робота з кодом винесена в окремий захищений контур, яким керує Виконавець (Тетяна).

⸻

2. Рольова Модель (The Trinity)

2.1 Atlas (Архітектор / Supervisor)
*   **Роль:** Керівник проекту, Стратег.
*   **Відповідальність:**
    *   Прийом вхідної задачі від користувача.
    *   Декомпозиція задачі на менші етапи.
    *   Розподіл завдань між іншими агентами.
    *   Прийняття фінального рішення у спірних ситуаціях.
*   **Поведінка:** Виважена, стратегічна. Може сказати: "Тетяна, цей підхід занадто ризикований, давай спробуємо інакше".

2.2 Tetyana (Виконавець / Universal Operator)
*   **Роль:** Головний Оператор Системи.
*   **Відповідальність:**
    *   **General Tasks:** Виконання будь-яких дій в ОС (відкрити браузер, знайти файл, налаштувати систему).
    *   **Dev Tasks:** Написання коду (через Dev Subsystem).
    *   Робота з терміналом.
*   **Поведінка:** Практична, орієнтована на результат. Якщо задача не про код — робить сама. Якщо про код — активує Windsurf.

2.3 Grisha (Візор / Security & QA)
*   **Роль:** Безпека, Контроль якості, "Очі" системи.
*   **Відповідальність:**
    *   Візуальний контроль (Vision) — підтвердження, що на екрані відбувається те, що очікується.
    *   Security Audit — блокування деструктивних команд (rm -rf /, upload keys і т.д.).
    *   Код-рев'ю — аналіз планів Тетяни перед виконанням.
*   **Поведінка:** Критична, підозріла. Має право "вето" на дії Тетяни.

⸻

3. Архітектура Взаємодії (Communication Layer)

3.1 Протокол "Вільний Діалог" (AutoGen-style)
Замість жорсткого ланцюжка (Chain), система використовує граф станів (State Graph), де агенти обмінюються повідомленнями у спільній історії (Thread).

**Типовий сценарій:**
1.  **Atlas:** "Маємо задачу X. Тетяна, запропонуй план реалізації."
2.  **Tetyana:** "Пропоную використати бібліотеку Y. Ось план дій..."
3.  **Grisha:** "Чекай. Бібліотека Y має вразливість CVE-xyz. Тетяна, знайди безпечний аналог."
4.  **Tetyana:** "Зрозуміла. Використаю бібліотеку Z. Atlas, затверджуєш?"
5.  **Atlas:** "Затверджую. Тетяна, приступай. Гріша, слідкуй за виконанням."

3.2 Оркестрація (Graph Core)
*   Для керування станом розмови використовується **State Graph** (наприклад, на базі LangGraph або custom state machine).
*   Граф визначає переходи: хто говорить наступним, коли діалог переходить у фазу виконання (Execution), а коли повертається на доопрацювання.

1.1 Універсальність
Система є універсальною. Вона обробляє будь-які запити користувача:
*   Робота з ОС (файли, додатки, налаштування).
*   Робота з медіа та браузером.
*   Пошук інформації.
*   **Розробка (як окремий важливий під-процес).**

1.2 Спеціалізація на коді (Dev Subsystem)
Лише якщо завдання стосується код/розробки, воно виконується через спеціалізований контур **Dev Subsystem**. Для всіх інших задач використовуються стандартні інструменти ОС.

⸻

4. Підсистема Розробки (Dev Subsystem) — "Cascading Control"
**Архітектурна Специфікація**

4.1 Мета та Принцип Каскаду
Реалізовано каскадну агентну архітектуру, де **Copilot (GPT-4o)** виступає мета-контролером, що керує **Windsurf IDE (GPT-5.2)** через шину **Continue CLI**.

**Компоненти Каскаду:**
1.  **Copilot LLM (Meta-Controller):**
    *   Роль: Контроль, аналіз, прийняття рішень (Stop-умови).
    *   Реалізація: `providers/copilot.py` (Atlas/Tetyana Personas).
    *   Принцип: Єдиний носій "волі" системи.
2.  **Continue CLI (Instrumental Bus):**
    *   Роль: Маршрутизатор та виконавець.
    *   Функція: Передає запити у Windsurf, повертає відповіді, не має власного reasoning.
3.  **Windsurf IDE (Execution Engine):**
    *   Роль: Глибокий аналіз коду та генерація рішень.
    *   Модель: GPT-5.2 Medium Reasoning.
    *   Статус: Працює у стандартному режимі, вважаючи, що спілкується з користувачем.

4.2 Оркестрація (LangGraph & TaskGraph)
Система керується двома графами:
*   **LangGraph (Conversation Flow):** Керує станом діалогу між персонами (Atlas -> Tetyana -> Grisha) та циклами перевірки.
*   **TaskGraph (Execution State):** Відстежує прогрес виконання задачі (Task ID, Status, Artifacts) через `task.md` та пам'ять агента.

4.3 Потік Взаємодії (Interaction Flow)
1.  **Copilot (Tetyana)** формує запит (людською мовою).
2.  **Continue CLI** передає запит у Windsurf (Tool: `send_to_windsurf`).
3.  **Windsurf** генерує код/відповідь.
4.  **Continue CLI** повертає результат Tetyana.
5.  **Copilot (Tetyana/Grisha)** аналізує:
    *   Достатність відповіді? -> *Stop* або *Continue*.
    *   Помилки? -> *Re-prompt*.

4.4 Критерій Успіху
Система успішна, якщо взаємодія "Copilot ↔ Windsurf" дає той самий стиль та глибину контролю, що й ручна робота користувача.

5. Потік Виконання Задачі (End-to-End Flow)

1.  **User Request:** Користувач ставить задачу.
2.  **Planning Phase (The Trinity Chat):**
    *   Atlas аналізує, формує стратегію.
    *   Обговорення з Тетяною та Грішею.
    *   Затвердження плану.
3.  **Execution Phase (Tetyana's Action):**
    *   Тетяна активує Dev Subsystem.
    *   Виконується робота через Windsurf або Continue CLI.
4.  **Verification Phase (Grisha's Watch):**
    *   Гріша перевіряє результат (через Vision або аналіз файлів).
    *   Якщо помилка → повернення до Planning/Execution.
5.  **Completion:** Atlas звітує користувачу.

⸻

6. Технічні Вимоги до Реалізації

6.1 Граф Станів
*   Реалізувати граф (Nodes: Atlas, Tetyana, Grisha).
*   Conditional Edges: Логіка переходу (наприклад, `if approve -> execute`, `if reject -> replan`).

6.2 Інтеграція Providers
*   Переконатися, що `providers/copilot.py` коректно обробляє запити від імені різних персон (System Prompts для Atlas/Tetyana/Grisha) або використовується як бекенд для інструментального рівня.

6.3 Безпека
*   Гріша повинен мати незалежний канал аналізу (не просто вірити Тетяні на слово).
*   Дії в Dev Subsystem мають бути атомарними та зворотними (git commits).

6.4 Інтеграція з Діючою Системою
*   **Плавна Міграція:** Нова архітектура "Trinity" має бути інтегрована в існуючий репозиторій (`/Users/dev/Documents/GitHub/System`) як розвиток, а не як заміна "з нуля".
*   **Використання Існуючих Модулів:** Максимально перевикористовувати наявний код в `system_ai/`, `tui/` та `providers/`.
*   **Сумісність:** Зберегти працездатність існуючих CLI-команд та TUI-інтерфейсу під час переходу.

⸻

7. Критерій Успіху
Система, де агенти "живо" обговорюють задачу, знаходять помилки в планах один одного ДО виконання, а кодинг відбувається через надійний каскад Dev Subsystem. Інтеграція в поточний `cli.py` виконана прозоро для користувача.